<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path E: The Viewer / Player | SIREN Tech Guide</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root { --siren-red: #e63946; --siren-orange: #f77f00; --siren-gradient: linear-gradient(135deg, #e63946 0%, #f77f00 100%); --dark-bg: #0a0a0b; --card-bg: rgba(255, 255, 255, 0.03); --card-border: rgba(255, 255, 255, 0.08); --text-primary: #ffffff; --text-secondary: rgba(255, 255, 255, 0.6); --text-muted: rgba(255, 255, 255, 0.4); }
        body { font-family: 'Inter', sans-serif; background: var(--dark-bg); color: var(--text-primary); min-height: 100vh; line-height: 1.7; }
        .ambient-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
        .ambient-orb { position: absolute; border-radius: 50%; filter: blur(100px); opacity: 0.2; }
        .orb-1 { width: 500px; height: 500px; background: var(--siren-red); top: -150px; right: -150px; }
        .orb-2 { width: 300px; height: 300px; background: var(--siren-orange); bottom: 20%; left: -100px; }
        .container { position: relative; z-index: 1; max-width: 900px; margin: 0 auto; padding: 40px 24px 80px; }
        .top-nav { display: flex; align-items: center; justify-content: space-between; margin-bottom: 60px; padding-bottom: 20px; border-bottom: 1px solid var(--card-border); }
        .back-link { display: flex; align-items: center; gap: 8px; color: var(--text-secondary); text-decoration: none; font-size: 14px; }
        .back-link:hover { color: var(--text-primary); }
        .back-link svg { width: 20px; height: 20px; }
        .nav-logo { font-size: 12px; font-weight: 600; letter-spacing: 2px; text-transform: uppercase; background: var(--siren-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .page-header { margin-bottom: 48px; }
        .path-badge { display: inline-flex; align-items: center; gap: 12px; margin-bottom: 20px; }
        .path-letter { width: 48px; height: 48px; background: var(--siren-gradient); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: 700; }
        .path-label { font-size: 13px; font-weight: 600; letter-spacing: 2px; text-transform: uppercase; color: var(--siren-orange); }
        .page-title { font-size: clamp(32px, 5vw, 48px); font-weight: 700; margin-bottom: 16px; }
        .page-subtitle { font-size: 18px; color: var(--text-secondary); }
        .section { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 20px; padding: 36px; margin-bottom: 32px; backdrop-filter: blur(20px); }
        .section-num { font-size: 12px; font-weight: 600; letter-spacing: 2px; text-transform: uppercase; color: var(--siren-orange); margin-bottom: 12px; }
        .section h2 { font-size: 24px; font-weight: 600; margin-bottom: 20px; }
        .section h3 { font-size: 18px; font-weight: 600; margin: 28px 0 16px; }
        .section p { color: var(--text-secondary); margin-bottom: 16px; }
        .section strong { color: var(--text-primary); }
        .section ul { color: var(--text-secondary); margin: 16px 0; padding-left: 24px; }
        .section li { margin-bottom: 8px; }
        .code-block { background: rgba(0, 0, 0, 0.4); border: 1px solid var(--card-border); border-radius: 12px; padding: 20px; margin: 20px 0; overflow-x: auto; }
        .code-block code { font-family: 'JetBrains Mono', monospace; font-size: 13px; color: #e0e0e0; line-height: 1.6; white-space: pre; }
        .comment { color: #6a9955; }
        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .number { color: #b5cea8; }
        .function { color: #dcdcaa; }
        .info-box { background: rgba(247, 127, 0, 0.1); border-left: 3px solid var(--siren-orange); padding: 16px 20px; margin: 20px 0; border-radius: 0 8px 8px 0; }
        .info-box p { margin: 0; font-size: 14px; }
        .property-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin: 20px 0; }
        .property-card { background: rgba(255, 255, 255, 0.02); border: 1px solid var(--card-border); border-radius: 12px; padding: 20px; }
        .property-name { font-family: 'JetBrains Mono', monospace; font-size: 14px; color: var(--siren-orange); margin-bottom: 8px; }
        .property-desc { font-size: 13px; color: var(--text-secondary); }
        .diagram { background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 32px; margin: 24px 0; text-align: center; font-family: 'JetBrains Mono', monospace; }
        .diagram-row { display: flex; align-items: center; justify-content: center; gap: 16px; margin: 12px 0; flex-wrap: wrap; }
        .diagram-box { background: rgba(230, 57, 70, 0.2); border: 1px solid rgba(230, 57, 70, 0.4); border-radius: 8px; padding: 12px 20px; font-size: 13px; }
        .diagram-arrow { color: var(--siren-orange); font-size: 20px; }
        .table-wrapper { overflow-x: auto; margin: 20px 0; }
        table { width: 100%; border-collapse: collapse; font-size: 14px; }
        th, td { padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--card-border); }
        th { color: var(--text-muted); font-weight: 600; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; }
        td { color: var(--text-secondary); }
        td strong { color: var(--text-primary); }
        .nav-footer { display: flex; justify-content: space-between; gap: 20px; margin-top: 48px; padding-top: 32px; border-top: 1px solid var(--card-border); flex-wrap: wrap; }
        .nav-btn { display: flex; align-items: center; gap: 12px; padding: 16px 24px; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 12px; text-decoration: none; color: var(--text-primary); flex: 1; min-width: 200px; }
        .nav-btn:hover { border-color: rgba(230, 57, 70, 0.4); transform: translateY(-2px); }
        .nav-btn.next { justify-content: flex-end; text-align: right; }
        .nav-btn-label { font-size: 12px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
        .nav-btn-title { font-weight: 600; }
        .nav-btn svg { width: 20px; height: 20px; stroke: var(--text-secondary); }
    </style>
</head>
<body>
    <div class="ambient-bg"><div class="ambient-orb orb-1"></div><div class="ambient-orb orb-2"></div></div>
    <div class="container">
        <nav class="top-nav">
            <a href="../" class="back-link"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>Back to Overview</a>
            <span class="nav-logo">SIREN Tech Guide</span>
        </nav>

        <header class="page-header">
            <div class="path-badge"><div class="path-letter">E</div><span class="path-label">Deep Dive</span></div>
            <h1 class="page-title">The Viewer / Player</h1>
            <p class="page-subtitle">Making gsplat.js do things it wasn't designed to do</p>
        </header>

        <section class="section">
            <div class="section-num">01</div>
            <h2>gsplat.js Overview</h2>
            <p><strong>gsplat.js</strong> is the leading open-source WebGL library for rendering Gaussian Splats in the browser. It's what makes real-time 3D splat viewing possible without plugins.</p>
            <div class="property-grid">
                <div class="property-card"><div class="property-name">Repo</div><div class="property-desc">github.com/huggingface/gsplat.js</div></div>
                <div class="property-card"><div class="property-name">Rendering</div><div class="property-desc">WebGL 2.0, GPU-accelerated</div></div>
                <div class="property-card"><div class="property-name">Formats</div><div class="property-desc">.splat, .ply files</div></div>
                <div class="property-card"><div class="property-name">Performance</div><div class="property-desc">30-60+ FPS on modern devices</div></div>
            </div>
            <h3>Basic Integration</h3>
            <div class="code-block"><code><span class="keyword">import</span> * <span class="keyword">as</span> SPLAT <span class="keyword">from</span> <span class="string">'gsplat'</span>;

<span class="comment">// Initialize renderer</span>
<span class="keyword">const</span> canvas = document.getElementById(<span class="string">'viewer'</span>);
<span class="keyword">const</span> renderer = <span class="keyword">new</span> SPLAT.WebGLRenderer(canvas);
<span class="keyword">const</span> scene = <span class="keyword">new</span> SPLAT.Scene();
<span class="keyword">const</span> camera = <span class="keyword">new</span> SPLAT.Camera();
<span class="keyword">const</span> controls = <span class="keyword">new</span> SPLAT.OrbitControls(camera, canvas);

<span class="comment">// Load splat</span>
<span class="keyword">await</span> SPLAT.Loader.LoadAsync(<span class="string">'scene.splat'</span>, scene, () => {});

<span class="comment">// Render loop</span>
<span class="keyword">function</span> <span class="function">animate</span>() {
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}
animate();</code></div>
        </section>

        <section class="section">
            <div class="section-num">02</div>
            <h2>Building a 4D Player</h2>
            <p>gsplat.js renders <strong>static</strong> scenes. For 4D video, we need to swap splats frame-by-frame.</p>
            <div class="code-block"><code><span class="keyword">class</span> <span class="function">FourDPlayer</span> {
    <span class="keyword">constructor</span>(canvas, manifestUrl) {
        <span class="keyword">this</span>.renderer = <span class="keyword">new</span> SPLAT.WebGLRenderer(canvas);
        <span class="keyword">this</span>.scene = <span class="keyword">new</span> SPLAT.Scene();
        <span class="keyword">this</span>.camera = <span class="keyword">new</span> SPLAT.Camera();
        <span class="keyword">this</span>.controls = <span class="keyword">new</span> SPLAT.OrbitControls(<span class="keyword">this</span>.camera, canvas);
        
        <span class="keyword">this</span>.manifest = <span class="keyword">null</span>;
        <span class="keyword">this</span>.splatCache = <span class="keyword">new</span> Map();  <span class="comment">// Frame index -> splat data</span>
        <span class="keyword">this</span>.currentFrame = <span class="number">0</span>;
        <span class="keyword">this</span>.isPlaying = <span class="keyword">false</span>;
        <span class="keyword">this</span>.fps = <span class="number">30</span>;
        
        <span class="keyword">this</span>.loadManifest(manifestUrl);
    }
    
    <span class="keyword">async</span> <span class="function">loadManifest</span>(url) {
        <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(url);
        <span class="keyword">this</span>.manifest = <span class="keyword">await</span> res.json();
        <span class="keyword">this</span>.fps = <span class="keyword">this</span>.manifest.fps || <span class="number">30</span>;
        
        <span class="comment">// Preload first keyframe</span>
        <span class="keyword">await</span> <span class="keyword">this</span>.loadFrame(<span class="number">0</span>);
        <span class="keyword">this</span>.render();
    }
    
    <span class="keyword">async</span> <span class="function">loadFrame</span>(frameIndex) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.splatCache.has(frameIndex)) {
            <span class="keyword">return</span> <span class="keyword">this</span>.splatCache.get(frameIndex);
        }
        
        <span class="comment">// Find nearest keyframe</span>
        <span class="keyword">const</span> keyframe = <span class="keyword">this</span>.findKeyframe(frameIndex);
        <span class="keyword">const</span> splatUrl = <span class="keyword">this</span>.manifest.keyframes[keyframe].file;
        
        <span class="comment">// Load the splat</span>
        <span class="keyword">const</span> splat = <span class="keyword">await</span> SPLAT.Loader.LoadAsync(splatUrl);
        
        <span class="comment">// Apply deltas if not a keyframe</span>
        <span class="keyword">if</span> (frameIndex !== keyframe) {
            <span class="keyword">await</span> <span class="keyword">this</span>.applyDeltas(splat, keyframe, frameIndex);
        }
        
        <span class="keyword">this</span>.splatCache.set(frameIndex, splat);
        <span class="keyword">return</span> splat;
    }
    
    <span class="function">play</span>() {
        <span class="keyword">this</span>.isPlaying = <span class="keyword">true</span>;
        <span class="keyword">this</span>.lastFrameTime = performance.now();
        <span class="keyword">this</span>.playLoop();
    }
    
    <span class="function">playLoop</span>() {
        <span class="keyword">if</span> (!<span class="keyword">this</span>.isPlaying) <span class="keyword">return</span>;
        
        <span class="keyword">const</span> now = performance.now();
        <span class="keyword">const</span> elapsed = now - <span class="keyword">this</span>.lastFrameTime;
        <span class="keyword">const</span> frameTime = <span class="number">1000</span> / <span class="keyword">this</span>.fps;
        
        <span class="keyword">if</span> (elapsed >= frameTime) {
            <span class="keyword">this</span>.currentFrame++;
            <span class="keyword">if</span> (<span class="keyword">this</span>.currentFrame >= <span class="keyword">this</span>.manifest.total_frames) {
                <span class="keyword">this</span>.currentFrame = <span class="number">0</span>;  <span class="comment">// Loop</span>
            }
            <span class="keyword">this</span>.displayFrame(<span class="keyword">this</span>.currentFrame);
            <span class="keyword">this</span>.lastFrameTime = now;
        }
        
        requestAnimationFrame(() => <span class="keyword">this</span>.playLoop());
    }
    
    <span class="keyword">async</span> <span class="function">displayFrame</span>(frameIndex) {
        <span class="keyword">const</span> splat = <span class="keyword">await</span> <span class="keyword">this</span>.loadFrame(frameIndex);
        <span class="keyword">this</span>.scene.clear();
        <span class="keyword">this</span>.scene.add(splat);
        <span class="keyword">this</span>.render();
    }
    
    <span class="function">render</span>() {
        <span class="keyword">this</span>.controls.update();
        <span class="keyword">this</span>.renderer.render(<span class="keyword">this</span>.scene, <span class="keyword">this</span>.camera);
    }
}</code></div>
        </section>

        <section class="section">
            <div class="section-num">03</div>
            <h2>Camera Controls for Adult Content</h2>
            <p>Standard orbit controls aren't ideal. We need <strong>constrained, intuitive</strong> controls.</p>
            <h3>Custom Control Scheme</h3>
            <div class="code-block"><code><span class="keyword">class</span> <span class="function">SirenControls</span> {
    <span class="keyword">constructor</span>(camera, canvas, options = {}) {
        <span class="keyword">this</span>.camera = camera;
        <span class="keyword">this</span>.canvas = canvas;
        
        <span class="comment">// Constraints</span>
        <span class="keyword">this</span>.minPolarAngle = options.minPolar || <span class="number">0.1</span>;   <span class="comment">// Don't go underground</span>
        <span class="keyword">this</span>.maxPolarAngle = options.maxPolar || Math.PI - <span class="number">0.1</span>;
        <span class="keyword">this</span>.minDistance = options.minDist || <span class="number">1</span>;
        <span class="keyword">this</span>.maxDistance = options.maxDist || <span class="number">10</span>;
        
        <span class="comment">// Target (focus point)</span>
        <span class="keyword">this</span>.target = options.target || { x: <span class="number">0</span>, y: <span class="number">1</span>, z: <span class="number">0</span> };
        
        <span class="comment">// Current state</span>
        <span class="keyword">this</span>.spherical = { radius: <span class="number">3</span>, phi: Math.PI / <span class="number">2</span>, theta: <span class="number">0</span> };
        
        <span class="keyword">this</span>.setupEventListeners();
    }
    
    <span class="function">setupEventListeners</span>() {
        <span class="keyword">let</span> isDragging = <span class="keyword">false</span>;
        <span class="keyword">let</span> lastX, lastY;
        
        <span class="keyword">this</span>.canvas.addEventListener(<span class="string">'pointerdown'</span>, (e) => {
            isDragging = <span class="keyword">true</span>;
            lastX = e.clientX;
            lastY = e.clientY;
            <span class="keyword">this</span>.canvas.setPointerCapture(e.pointerId);
        });
        
        <span class="keyword">this</span>.canvas.addEventListener(<span class="string">'pointermove'</span>, (e) => {
            <span class="keyword">if</span> (!isDragging) <span class="keyword">return</span>;
            
            <span class="keyword">const</span> deltaX = e.clientX - lastX;
            <span class="keyword">const</span> deltaY = e.clientY - lastY;
            
            <span class="comment">// Rotate around target</span>
            <span class="keyword">this</span>.spherical.theta -= deltaX * <span class="number">0.01</span>;
            <span class="keyword">this</span>.spherical.phi -= deltaY * <span class="number">0.01</span>;
            
            <span class="comment">// Clamp polar angle</span>
            <span class="keyword">this</span>.spherical.phi = Math.max(
                <span class="keyword">this</span>.minPolarAngle,
                Math.min(<span class="keyword">this</span>.maxPolarAngle, <span class="keyword">this</span>.spherical.phi)
            );
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            <span class="keyword">this</span>.updateCamera();
        });
        
        <span class="keyword">this</span>.canvas.addEventListener(<span class="string">'wheel'</span>, (e) => {
            e.preventDefault();
            <span class="keyword">this</span>.spherical.radius += e.deltaY * <span class="number">0.01</span>;
            <span class="keyword">this</span>.spherical.radius = Math.max(
                <span class="keyword">this</span>.minDistance,
                Math.min(<span class="keyword">this</span>.maxDistance, <span class="keyword">this</span>.spherical.radius)
            );
            <span class="keyword">this</span>.updateCamera();
        });
    }
    
    <span class="function">updateCamera</span>() {
        <span class="keyword">const</span> { radius, phi, theta } = <span class="keyword">this</span>.spherical;
        
        <span class="keyword">this</span>.camera.position.x = <span class="keyword">this</span>.target.x + radius * Math.sin(phi) * Math.cos(theta);
        <span class="keyword">this</span>.camera.position.y = <span class="keyword">this</span>.target.y + radius * Math.cos(phi);
        <span class="keyword">this</span>.camera.position.z = <span class="keyword">this</span>.target.z + radius * Math.sin(phi) * Math.sin(theta);
        
        <span class="keyword">this</span>.camera.lookAt(<span class="keyword">this</span>.target);
    }
}</code></div>
        </section>

        <section class="section">
            <div class="section-num">04</div>
            <h2>Audio Synchronization</h2>
            <p>4D content needs perfect audio sync. Use the Web Audio API.</p>
            <div class="code-block"><code><span class="keyword">class</span> <span class="function">SyncedAudioPlayer</span> {
    <span class="keyword">constructor</span>(audioUrl) {
        <span class="keyword">this</span>.audioContext = <span class="keyword">new</span> AudioContext();
        <span class="keyword">this</span>.audioBuffer = <span class="keyword">null</span>;
        <span class="keyword">this</span>.sourceNode = <span class="keyword">null</span>;
        <span class="keyword">this</span>.startTime = <span class="number">0</span>;
        <span class="keyword">this</span>.pauseTime = <span class="number">0</span>;
        
        <span class="keyword">this</span>.loadAudio(audioUrl);
    }
    
    <span class="keyword">async</span> <span class="function">loadAudio</span>(url) {
        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);
        <span class="keyword">const</span> arrayBuffer = <span class="keyword">await</span> response.arrayBuffer();
        <span class="keyword">this</span>.audioBuffer = <span class="keyword">await</span> <span class="keyword">this</span>.audioContext.decodeAudioData(arrayBuffer);
    }
    
    <span class="function">play</span>(fromTime = <span class="number">0</span>) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.sourceNode) {
            <span class="keyword">this</span>.sourceNode.stop();
        }
        
        <span class="keyword">this</span>.sourceNode = <span class="keyword">this</span>.audioContext.createBufferSource();
        <span class="keyword">this</span>.sourceNode.buffer = <span class="keyword">this</span>.audioBuffer;
        <span class="keyword">this</span>.sourceNode.connect(<span class="keyword">this</span>.audioContext.destination);
        
        <span class="keyword">this</span>.startTime = <span class="keyword">this</span>.audioContext.currentTime - fromTime;
        <span class="keyword">this</span>.sourceNode.start(<span class="number">0</span>, fromTime);
    }
    
    <span class="function">getCurrentTime</span>() {
        <span class="keyword">return</span> <span class="keyword">this</span>.audioContext.currentTime - <span class="keyword">this</span>.startTime;
    }
    
    <span class="function">seekTo</span>(time) {
        <span class="keyword">this</span>.play(time);
    }
}

<span class="comment">// Integration with 4D Player</span>
<span class="keyword">class</span> <span class="function">SyncedFourDPlayer</span> <span class="keyword">extends</span> FourDPlayer {
    <span class="keyword">constructor</span>(canvas, manifestUrl) {
        <span class="keyword">super</span>(canvas, manifestUrl);
        <span class="keyword">this</span>.audio = <span class="keyword">null</span>;
    }
    
    <span class="keyword">async</span> <span class="function">loadManifest</span>(url) {
        <span class="keyword">await</span> <span class="keyword">super</span>.loadManifest(url);
        <span class="keyword">if</span> (<span class="keyword">this</span>.manifest.audio) {
            <span class="keyword">this</span>.audio = <span class="keyword">new</span> SyncedAudioPlayer(<span class="keyword">this</span>.manifest.audio.file);
        }
    }
    
    <span class="function">playLoop</span>() {
        <span class="keyword">if</span> (!<span class="keyword">this</span>.isPlaying) <span class="keyword">return</span>;
        
        <span class="comment">// Sync to audio time instead of frame counting</span>
        <span class="keyword">const</span> audioTime = <span class="keyword">this</span>.audio.getCurrentTime();
        <span class="keyword">const</span> targetFrame = Math.floor(audioTime * <span class="keyword">this</span>.fps);
        
        <span class="keyword">if</span> (targetFrame !== <span class="keyword">this</span>.currentFrame) {
            <span class="keyword">this</span>.currentFrame = targetFrame;
            <span class="keyword">this</span>.displayFrame(<span class="keyword">this</span>.currentFrame);
        }
        
        requestAnimationFrame(() => <span class="keyword">this</span>.playLoop());
    }
}</code></div>
        </section>

        <section class="section">
            <div class="section-num">05</div>
            <h2>Performance Optimization</h2>
            <p>Smooth playback requires careful optimization. Key strategies:</p>
            <h3>1. Frame Preloading</h3>
            <div class="code-block"><code><span class="keyword">class</span> <span class="function">PreloadingPlayer</span> <span class="keyword">extends</span> FourDPlayer {
    <span class="keyword">constructor</span>(canvas, manifestUrl) {
        <span class="keyword">super</span>(canvas, manifestUrl);
        <span class="keyword">this</span>.preloadAhead = <span class="number">30</span>;  <span class="comment">// Preload 1 second ahead</span>
    }
    
    <span class="keyword">async</span> <span class="function">displayFrame</span>(frameIndex) {
        <span class="keyword">await</span> <span class="keyword">super</span>.displayFrame(frameIndex);
        
        <span class="comment">// Preload upcoming frames in background</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i <= <span class="keyword">this</span>.preloadAhead; i++) {
            <span class="keyword">const</span> futureFrame = (frameIndex + i) % <span class="keyword">this</span>.manifest.total_frames;
            <span class="keyword">if</span> (!<span class="keyword">this</span>.splatCache.has(futureFrame)) {
                <span class="comment">// Non-blocking load</span>
                <span class="keyword">this</span>.loadFrame(futureFrame);
            }
        }
        
        <span class="comment">// Evict old frames to save memory</span>
        <span class="keyword">this</span>.evictOldFrames(frameIndex);
    }
    
    <span class="function">evictOldFrames</span>(currentFrame) {
        <span class="keyword">const</span> keepRange = <span class="number">60</span>;  <span class="comment">// Keep 2 seconds of frames</span>
        <span class="keyword">for</span> (<span class="keyword">const</span> [frame, splat] <span class="keyword">of</span> <span class="keyword">this</span>.splatCache) {
            <span class="keyword">const</span> distance = Math.min(
                Math.abs(frame - currentFrame),
                <span class="keyword">this</span>.manifest.total_frames - Math.abs(frame - currentFrame)
            );
            <span class="keyword">if</span> (distance > keepRange) {
                splat.dispose();
                <span class="keyword">this</span>.splatCache.delete(frame);
            }
        }
    }
}</code></div>
            <h3>2. WebWorker Decoding</h3>
            <p>Move splat parsing off the main thread:</p>
            <div class="code-block"><code><span class="comment">// worker.js</span>
self.onmessage = <span class="keyword">async</span> (e) => {
    <span class="keyword">const</span> { frameIndex, url } = e.data;
    
    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);
    <span class="keyword">const</span> buffer = <span class="keyword">await</span> response.arrayBuffer();
    
    <span class="comment">// Parse splat data (CPU-intensive)</span>
    <span class="keyword">const</span> parsed = parseSplatBuffer(buffer);
    
    <span class="comment">// Transfer back to main thread</span>
    self.postMessage(
        { frameIndex, data: parsed },
        [parsed.positions.buffer, parsed.colors.buffer]  <span class="comment">// Transfer ownership</span>
    );
};

<span class="comment">// main.js</span>
<span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);

worker.onmessage = (e) => {
    <span class="keyword">const</span> { frameIndex, data } = e.data;
    <span class="keyword">const</span> splat = createSplatFromParsed(data);
    splatCache.set(frameIndex, splat);
};</code></div>
        </section>

        <section class="section">
            <div class="section-num">06</div>
            <h2>Mobile Considerations</h2>
            <p>Mobile devices have <strong>limited GPU memory</strong> and <strong>thermal constraints</strong>.</p>
            <div class="property-grid">
                <div class="property-card"><div class="property-name">Reduce Gaussians</div><div class="property-desc">Use LOD 1 (~200K) instead of full</div></div>
                <div class="property-card"><div class="property-name">Lower FPS</div><div class="property-desc">24fps acceptable on mobile</div></div>
                <div class="property-card"><div class="property-name">Touch Controls</div><div class="property-desc">Pinch-to-zoom, swipe-to-rotate</div></div>
                <div class="property-card"><div class="property-name">Battery Aware</div><div class="property-desc">Reduce quality when battery low</div></div>
            </div>
            <div class="code-block"><code><span class="keyword">function</span> <span class="function">getDeviceProfile</span>() {
    <span class="keyword">const</span> isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
    <span class="keyword">const</span> gpu = getGPUTier();  <span class="comment">// Using detect-gpu library</span>
    
    <span class="keyword">if</span> (isMobile || gpu.tier < <span class="number">2</span>) {
        <span class="keyword">return</span> {
            lodLevel: <span class="number">1</span>,
            maxGaussians: <span class="number">200000</span>,
            targetFps: <span class="number">24</span>,
            preloadFrames: <span class="number">15</span>
        };
    }
    
    <span class="keyword">return</span> {
        lodLevel: <span class="number">2</span>,
        maxGaussians: <span class="number">1000000</span>,
        targetFps: <span class="number">30</span>,
        preloadFrames: <span class="number">30</span>
    };
}</code></div>
        </section>

        <section class="section">
            <div class="section-num">07</div>
            <h2>UI Integration</h2>
            <p>The player needs standard video controls plus 3D-specific features.</p>
            <h3>Control Bar Features</h3>
            <ul>
                <li><strong>Play/Pause</strong> — Standard toggle</li>
                <li><strong>Seek bar</strong> — Scrub through timeline</li>
                <li><strong>Reset View</strong> — Return camera to default position</li>
                <li><strong>Fullscreen</strong> — Immersive viewing</li>
                <li><strong>Quality selector</strong> — LOD level toggle</li>
                <li><strong>VR Mode</strong> — WebXR for headsets (future)</li>
            </ul>
            <div class="info-box"><p><strong>UX Tip:</strong> Auto-hide controls after 3 seconds of no interaction to maximize immersion.</p></div>
        </section>

        <section class="section">
            <div class="section-num">08</div>
            <h2>Future: WebXR Integration</h2>
            <p>VR headsets (Quest, Vision Pro) can display gaussian splats natively. This is a <strong>massive opportunity</strong> for immersive adult content.</p>
            <div class="code-block"><code><span class="comment">// Check for WebXR support</span>
<span class="keyword">if</span> (navigator.xr) {
    <span class="keyword">const</span> supported = <span class="keyword">await</span> navigator.xr.isSessionSupported(<span class="string">'immersive-vr'</span>);
    
    <span class="keyword">if</span> (supported) {
        <span class="keyword">const</span> session = <span class="keyword">await</span> navigator.xr.requestSession(<span class="string">'immersive-vr'</span>);
        
        <span class="comment">// Render splats in stereo for VR</span>
        session.requestAnimationFrame(<span class="keyword">function</span> <span class="function">onXRFrame</span>(time, frame) {
            <span class="keyword">const</span> pose = frame.getViewerPose(referenceSpace);
            
            <span class="keyword">for</span> (<span class="keyword">const</span> view <span class="keyword">of</span> pose.views) {
                <span class="comment">// Render splat scene for each eye</span>
                renderer.render(scene, view.projectionMatrix, view.transform);
            }
            
            session.requestAnimationFrame(onXRFrame);
        });
    }
}</code></div>
            <div class="info-box"><p><strong>Note:</strong> WebXR for splats is still experimental. Keep watching gsplat.js and Three.js for updates.</p></div>
        </section>

        <nav class="nav-footer">
            <a href="../path-d-infrastructure/" class="nav-btn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg><div><div class="nav-btn-label">Previous</div><div class="nav-btn-title">D: Training Infrastructure</div></div></a>
            <a href="../" class="nav-btn next"><div><div class="nav-btn-label">Back to</div><div class="nav-btn-title">Overview</div></div><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg></a>
        </nav>
    </div>
    <script>gsap.from('.page-header', { opacity: 0, y: 30, duration: 0.8 }); gsap.from('.section', { opacity: 0, y: 40, duration: 0.8, stagger: 0.15, delay: 0.2 });</script>
</body>
</html>
